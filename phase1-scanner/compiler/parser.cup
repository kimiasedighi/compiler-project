package compiler;
import java_cup.runtime.*;
import AST.*;
import AST.Node;
import AST.NodeType;

parser code {:
     //LexerP s;
     //parser(LexerP s){ this.s=s; }
     //protected void report_expected_token_ids(){ }
     protected Program root;

     void setRoot(Program p) { this.root = p; }

     public Program getRoot() { return this.root; }
:}

//init with {:  :};
//scan with {: return s.next_token(); :};

/* terminals */

//Reserved Words:
terminal INTEGER, DOUBLE, BOOLEAN, STRING, VOID;
terminal CLASS, IMPORT, FUNCTION, LINE;
terminal FOR, WHILE, IF, ELSE, BREAK, CONTINUE;
terminal RETURN, NEW, THIS, NULL, NEWARRAY;
terminal READINTEGER, READLINE, PRINT, DTOI, ITOD, BTOI, ITOB;
terminal PRIVATE, PUBLIC;


//Relational Symbols:
terminal EQUAL, NOTEQUAL, LESS, GREATER, LESSEQUAL, GREATEREQUAL;

//Ligical Symbols:
terminal AND, OR, NOT;

//Arithmitic symbols:
terminal DIV, MUL, ADD, SUB, MOD;

//Assignment Symbols
terminal ASSIGN, ASSIGNADD, ASSIGNSUB, ASSIGNMUL, ASSIGNDIV;

//Other Symbols:
terminal SEMICOLON, COMMA, LEFTBRACKET, RIGHTBRACKET;
terminal DOT, LEFTPARANTHESIS, RIGHTPARANTHESIS, LEFTCURLY, RIGHTCURLY;

//IDENTIFIER:
terminal IDENTIFIER, DEFINE;

//Constants:
terminal INTCONST, DOUBLECONST, STRINGCONST, BOOLCONST;


/* Non terminals */

nonterminal Node Program;
nonterminal Node Macro;

// declarations AND types
nonterminal Node Decl;
nonterminal Node VariableDecl;
nonterminal Node FunctionDecl;
nonterminal Node ClassDecl;

// DEFINE Variable
nonterminal Node Variable;

// types of definitions except VOID
nonterminal Node Type;

// args of functions
nonterminal Node Formals;

//statement block
nonterminal Node StatementBlock;

// methods AND variables in class
nonterminal Node Field;

//PUBLIC OR PRIVATE
nonterminal Node AccessMode;

//statement
nonterminal Node Statement;
nonterminal Node IfStatement;
nonterminal Node WhileStatement;
nonterminal Node ForStatement;
nonterminal Node ElsePrime;
nonterminal Node BreakStatement;
nonterminal Node ContinueStatement;
nonterminal Node ReturnStatement;
nonterminal Node PrintStatement;

//expressions
nonterminal Node Expression;
nonterminal Node LValue;
nonterminal Node Constant;
nonterminal Node Call;
nonterminal Node Actuals;

//plus
nonterminal Node DeclPlus;
nonterminal Node MacroPlus;
nonterminal Node ExpressionPlusComma;
nonterminal Node StatementPlus;
nonterminal Node IdPlus;
nonterminal Node FieldPlus;
nonterminal Node VariableDeclPlus;
nonterminal Node VariablePlusComma;

/**/

/* precedence  */
precedence left ELSE;
precedence left LEFTBRACKET;
precedence left COMMA;
precedence left ASSIGN, ASSIGNADD, ASSIGNSUB, ASSIGNMUL, ASSIGNSUB;
precedence left OR;
precedence left AND;
precedence left EQUAL, NOTEQUAL;
precedence left LESS, GREATER, LESSEQUAL, GREATEREQUAL;
precedence left ADD, SUB;
precedence left MUL, DIV, MOD;
precedence left NOT;
precedence left LEFTPARANTHESIS, RIGHTPARANTHESIS, DOT;
/**/

start with Program;

Program  ::= DeclPlus:dp
            {: RESULT=dp; :}
           | MacroPlus DeclPlus; // TODO

Decl ::= VariableDecl:v {: RESULT=v; :}
       | FunctionDecl:f {: RESULT=f; :}
       | ClassDecl:c {: RESULT=c; :};

DeclPlus ::= DeclPlus:dp Decl:d
            {:RESULT=dp;
              d.addChild(d);
              d.setParrent(RESULT);
            :}
           | Decl:d
            {:RESULT= new BaseNode(NodeType.DECLARATION);;
              RESULT.addChild(d);
              d.setParrent(RESULT);
            :}
           ;

Macro ::= IMPORT STRINGCONST // TODO
        | DEFINE;

MacroPlus ::= MacroPlus Macro // TODO
            | Macro;

VariableDecl ::= Variable:v SEMICOLON {: RESULT=v; :};

VariableDeclPlus ::= VariableDeclPlus:vdp VariableDecl:vd
            {:RESULT=vdp;
              RESULT.addChild(vd);
              vd.setParrent(RESULT);
            :}
            | VariableDecl:vd
            {:RESULT= new BaseNode(NodeType.VARIABLES);;
              RESULT.addChild(vd);
              vd.setParrent(RESULT);
            :}
            ;

Variable ::= Type:t IDENTIFIER:i
            {:RESULT= new BaseNode(NodeType.VARIABLE_DECLARATION);
              RESULT.addChild(t);
              RESULT.addChild(i);
              t.setParent(RESULT);
              i.setParent(RESULT);;
              d.addChild(i);
              t.setParrent(RESULT);
            :}
            | IDENTIFIER:t IDENTIFIER:i // TODO
            {:RESULT= new BaseNode(NodeType.VARIABLE_DECLARATION);
              RESULT.addChild(t);
              RESULT.addChild(i);
              t.setParent(RESULT);
              i.setParent(RESULT);;
              d.addChild(i);
              t.setParrent(RESULT);
            :}
            ;

Type ::= INTEGER {: RESULT = new TypeNode(NodeType.INT_TYPE, PrimitiveType.INT); :}
       | DOUBLE {: RESULT = new TypeNode(NodeType.DOUBLE_TYPE, PrimitiveType.DOUBLE); :}
       | BOOLEAN {: RESULT = new TypeNode(NodeType.BOOLEAN_TYPE, PrimitiveType.BOOL); :}
       | STRING  {: RESULT = new TypeNode(NodeType.STRING_TYPE, PrimitiveType.STRING); :}
       | Type:t LEFTBRACKET RIGHTBRACKET
       {:
         RESULT = t;
         Node e = new BaseNode(NodeType.EMPTY_ARRAY);
         RESULT.addChild(e);
         e.setParent(RESULT);
         :}
       | IDENTIFIER:i LEFTBRACKET RIGHTBRACKET // TODO
       {:
         RESULT = i;
         Node e = new BaseNode(NodeType.EMPTY_ARRAY);
         RESULT.addChild(e);
         e.setParent(RESULT);
         :}
       ;

FunctionDecl ::= Type:t IDENTIFIER:i LEFTPARANTHESIS Formals:f RIGHTPARANTHESIS StatementBlock:s
         {:
			RESULT = new BaseNode(NodeType.FUNCTION_DECLARATION);
			RESULT.addChild(t, i, f, s);
			t.setParent(RESULT);
			i.setParent(RESULT);
			f.setParent(RESULT);
			s.setParent(RESULT);
        :}
        | IDENTIFIER:t IDENTIFIER:i LEFTPARANTHESIS Formals:f RIGHTPARANTHESIS StatementBlock:s // TODO
        {:
			RESULT = new BaseNode(NodeType.FUNCTION_DECLARATION);
			RESULT.addChild(t, i, f, s);
			t.setParent(RESULT);
			i.setParent(RESULT);
			f.setParent(RESULT);
			s.setParent(RESULT);
       :}
        | VOID IDENTIFIER:i LEFTPARANTHESIS Formals:f RIGHTPARANTHESIS StatementBlock:s
         {:
            RESULT = new BaseNode(NodeType.FUNCTION_DECLARATION);
            Node t = new TypeNode(NodeType.VOID, PrimitiveType.VOID);
            RESULT.addChild(t, i, f, s);
            t.setParent(RESULT);
            i.setParent(RESULT);
            f.setParent(RESULT);
            s.setParent(RESULT);
        :}
        ;

Formals ::=  VariablePlusComma:vpc {: RESULT=vpc; :}
        |;

VariablePlusComma ::= VariablePlusComma:vpc COMMA Variable:v // TODO
                    {:
                    RESULT = vpc;
                    RESULT.addChild(v);
                    v.setParent(RESULT);
                    :}
                    | Variable:v
                    {:
                    RESULT = new BaseNode(NodeType.VARIABLE_PLUS_COMMA);
                    RESULT.addChild(v);
                    v.setParent(RESULT);
                    :};

ClassDecl ::= CLASS IDENTIFIER:i LEFTCURLY FieldPlus:fp  RIGHTCURLY
            {:
                RESULT = new ClassNode();
                RESULT.addChild(i);
                RESULT.addChild(fp);
                i.setParent(RESULT);
                fp.setParent(RESULT);
            :}
            | CLASS IDENTIFIER:i LEFTCURLY RIGHTCURLY
            {:
                RESULT = new ClassNode();
                RESULT.addChild(i);
                i.setParent(RESULT);
            :}
            ;

FieldPlus ::= FieldPlus:fp Field:f
            {:
                RESULT = fs;
                RESULT.addChild(f);
                f.setParent(RESULT);
            :}
            | Field:f
            {:
                RESULT = new BaseNode(NodeType.FIELDS);
                RESULT.addChild(f);
                f.setParent(RESULT);
            :};

Field ::= AccessMode:am VariableDecl:vd
            {:
                RESULT = new BaseNode(NodeType.FIELD_DECLARATION);
                RESULT.addChild(am);
                RESULT.addChild(vd);
                am.setParent(RESULT);
                vd.setParent(RESULT);
            :}
            | AccessMode:am FunctionDecl:fd
            {:
                RESULT = new BaseNode(NodeType.FIELD_DECLARATION);
                RESULT.addChild(am);
                RESULT.addChild(fd);
                am.setParent(RESULT);
                fd.setParent(RESULT);
            :};

AccessMode ::= PRIVATE
            {:
                RESULT = new BaseNode(NodeType.FUNCTION_ACCESS);
                Node t = new BaseNode(NodeType.PRIVATE_ACCESS);
                RESULT.addChild(t);
                t.setParent(RESULT);
            :}
            | PUBLIC
            {:
                RESULT = new BaseNode(NodeType.FUNCTION_ACCESS);
                Node t = new BaseNode(NodeType.PUBLIC_ACCESS);
                RESULT.addChild(t);
                t.setParent(RESULT);
            :}
            |;

StatementBlock ::= LEFTCURLY RIGHTCURLY
                {:
                    RESULT = new BaseNode(NodeType.BLOCK);
                :}
                | LEFTCURLY VariableDeclPlus:vdp RIGHTCURLY
                {:
                 RESULT = new BaseNode(NodeType.BLOCK);
                 RESULT.addChild(vdp);
                 vdp.setParent(RESULT);
                :}
                | LEFTCURLY StatementPlus:sp RIGHTCURLY
                {:
                RESULT = new BaseNode(NodeType.BLOCK);
                RESULT.addChild(sp);
                sp.setParent(RESULT);
                :}
                | LEFTCURLY VariableDeclPlus:vdp StatementPlus:sp RIGHTCURLY
                {:
                 RESULT = new BaseNode(NodeType.BLOCK);
                 RESULT.addChild(vdp);
                 RESULT.addChild(sp);
                 vdp.setParent(RESULT);
                 sp.setParent(RESULT);
                :};

StatementPlus ::= StatementPlus:sp Statement:s
             {:
                 RESULT = sp;
                 RESULT.addChild(s);
                 s.setParent(RESULT);
             :}
            | Statement
              {:
                 RESULT = new BaseNode(NodeType.STATEMENTS);
                 RESULT.addChild(s);
                 s.setParent(RESULT);
             :};

Statement ::= Expression SEMICOLON | SEMICOLON | IfStatement | WhileStatement | ForStatement
            | BreakStatement | ContinueStatement | ReturnStatement | PrintStatement
            | StatementBlock;

IfStatement ::= IF LEFTPARANTHESIS Expression RIGHTPARANTHESIS Statement ElsePrime;

ElsePrime ::= ELSE Statement | ;

WhileStatement::= WHILE LEFTPARANTHESIS Expression RIGHTPARANTHESIS Statement;

ForStatement ::= FOR LEFTPARANTHESIS SEMICOLON Expression SEMICOLON RIGHTPARANTHESIS Statement
               | FOR LEFTPARANTHESIS Expression SEMICOLON Expression SEMICOLON RIGHTPARANTHESIS Statement
               | FOR LEFTPARANTHESIS  SEMICOLON Expression SEMICOLON Expression RIGHTPARANTHESIS Statement
               | FOR LEFTPARANTHESIS Expression SEMICOLON Expression SEMICOLON Expression RIGHTPARANTHESIS Statement;

ReturnStatement ::= RETURN SEMICOLON
                  | RETURN Expression SEMICOLON;

BreakStatement ::= BREAK SEMICOLON;

ContinueStatement ::= CONTINUE SEMICOLON;

PrintStatement ::= PRINT LEFTPARANTHESIS ExpressionPlusComma RIGHTPARANTHESIS SEMICOLON;

ExpressionPlusComma ::= ExpressionPlusComma COMMA Expression
                      | Expression ;


Expression ::= LValue ASSIGN Expression | IDENTIFIER ASSIGN Expression
             | LValue ASSIGNADD Expression | IDENTIFIER ASSIGNADD Expression
             | LValue ASSIGNSUB Expression | IDENTIFIER ASSIGNSUB Expression
             | LValue ASSIGNMUL Expression | IDENTIFIER ASSIGNMUL Expression
             | LValue ASSIGNDIV Expression | IDENTIFIER ASSIGNDIV Expression
             | Constant | LValue | IDENTIFIER
             | THIS | Call
             | LEFTPARANTHESIS Expression RIGHTPARANTHESIS
             | Expression ADD Expression | Expression SUB Expression
             | Expression MUL Expression | Expression DIV Expression | Expression MOD Expression
             | SUB Expression
             | Expression LESS Expression | Expression LESSEQUAL Expression
             | Expression GREATER Expression | Expression GREATEREQUAL Expression
             | Expression EQUAL Expression | Expression NOTEQUAL Expression
             | Expression AND Expression | Expression OR Expression | NOT Expression
             | READINTEGER LEFTPARANTHESIS RIGHTPARANTHESIS
             | READLINE LEFTPARANTHESIS RIGHTPARANTHESIS
             | NEW IDENTIFIER | NEWARRAY LEFTPARANTHESIS Expression COMMA Type RIGHTPARANTHESIS
             | NEWARRAY LEFTPARANTHESIS Expression COMMA IDENTIFIER RIGHTPARANTHESIS
             | ITOD LEFTPARANTHESIS Expression RIGHTPARANTHESIS
             | DTOI LEFTPARANTHESIS Expression RIGHTPARANTHESIS
             | ITOB LEFTPARANTHESIS Expression RIGHTPARANTHESIS
             | BTOI LEFTPARANTHESIS Expression RIGHTPARANTHESIS
             | LINE | FUNCTION;

LValue ::= Expression DOT IDENTIFIER
         | Expression LEFTBRACKET Expression RIGHTBRACKET
         | IDENTIFIER LEFTBRACKET Expression RIGHTBRACKET;

Call ::= IDENTIFIER LEFTPARANTHESIS Actuals RIGHTPARANTHESIS
       | Expression DOT IDENTIFIER LEFTPARANTHESIS Actuals RIGHTPARANTHESIS;

Actuals ::= ExpressionPlusComma | ;

Constant ::= INTCONST | DOUBLECONST | BOOLCONST | STRINGCONST | NULL;
