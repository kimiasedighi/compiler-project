package compiler;
import java_cup.runtime.*;
import AST.*;
import AST.Node;
import AST.NodeType;

parser code {:
     //LexerP s;
     //parser(LexerP s){ this.s=s; }
     //protected void report_expected_token_ids(){ }
     protected ProgramNode root;

     void setRoot(ProgramNode p) { this.root = p; }

     public ProgramNode getRoot() { return this.root; }
:}

//init with {:  :};
//scan with {: return s.next_token(); :};

/* terminals */

//Reserved Words:
terminal INTEGER, DOUBLE, BOOLEAN, STRING, VOID;
terminal CLASS, IMPORT, FUNCTION, LINE;
terminal FOR, WHILE, IF, ELSE, BREAK, CONTINUE;
terminal RETURN, NEW, THIS, NULL, NEWARRAY;
terminal READINTEGER, READLINE, PRINT, DTOI, ITOD, BTOI, ITOB;
terminal PRIVATE, PUBLIC;

//Relational Symbols:
terminal EQUAL, NOTEQUAL, LESS, GREATER, LESSEQUAL, GREATEREQUAL;

//Ligical Symbols:
terminal AND, OR, NOT;

//Arithmitic symbols:
terminal DIV, MUL, ADD, SUB, MOD;

//Assignment Symbols
terminal ASSIGN, ASSIGNADD, ASSIGNSUB, ASSIGNMUL, ASSIGNDIV;

//Other Symbols:
terminal SEMICOLON, COMMA, LEFTBRACKET, RIGHTBRACKET;
terminal DOT, LEFTPARANTHESIS, RIGHTPARANTHESIS, LEFTCURLY, RIGHTCURLY;

//IDENTIFIER:
terminal IDENTIFIER, DEFINE;

//Constants:
terminal INTCONST, DOUBLECONST, STRINGCONST, BOOLCONST;


/* Non terminals */

nonterminal Node Program;
nonterminal Node Macro;

// declarations AND types
nonterminal Node Decl;
nonterminal Node VariableDecl;
nonterminal Node FunctionDecl;
nonterminal Node ClassDecl;

// DEFINE Variable
nonterminal Node Variable;

// types of definitions except VOID
nonterminal Node Type;

// args of functions
nonterminal Node Formals;

//statement block
nonterminal Node StatementBlock;

// methods AND variables in class
nonterminal Node Field;

//PUBLIC OR PRIVATE
nonterminal Node AccessMode;

//statement
nonterminal Node Statement;
nonterminal Node IfStatement;
nonterminal Node WhileStatement;
nonterminal Node ForStatement;
nonterminal Node ElsePrime;
nonterminal Node BreakStatement;
nonterminal Node ContinueStatement;
nonterminal Node ReturnStatement;
nonterminal Node PrintStatement;

//expressions
nonterminal Node Expression;
nonterminal Node LValue;
nonterminal Node Constant;
nonterminal Node Call;
nonterminal Node Actuals;

//plus
nonterminal Node DeclPlus;
nonterminal Node MacroPlus;
nonterminal Node ExpressionPlusComma;
nonterminal Node StatementPlus;
nonterminal Node IdPlus;
nonterminal Node FieldPlus;
nonterminal Node VariableDeclPlus;
nonterminal Node VariablePlusComma;

/**/

/* precedence  */
precedence left ELSE;
precedence left LEFTBRACKET;
precedence left COMMA;
precedence left ASSIGN, ASSIGNADD, ASSIGNSUB, ASSIGNMUL, ASSIGNSUB;
precedence left OR;
precedence left AND;
precedence left EQUAL, NOTEQUAL;
precedence left LESS, GREATER, LESSEQUAL, GREATEREQUAL;
precedence left ADD, SUB;
precedence left MUL, DIV, MOD;
precedence left NOT;
precedence left LEFTPARANTHESIS, RIGHTPARANTHESIS, DOT;
/**/

start with Program;

Program  ::= DeclPlus:dp
            {:
            RESULT = new ProgramNode();
            RESULT.addChild(dp);
            dp.setParent(RESULT);
            :}
           | MacroPlus:mp DeclPlus:dp // TODO
            {:
            RESULT = new ProgramNode();
            RESULT.addChild(mp);
            RESULT.addChild(dp);
            mp.setParent(RESULT);
            dp.setParent(RESULT);
            :};

Decl ::= VariableDecl:v {: RESULT=v; :}
       | FunctionDecl:f {: RESULT=f; :}
       | ClassDecl:c {: RESULT=c; :};

DeclPlus ::= DeclPlus:dp Decl:d
            {:RESULT=dp;
              dp.addChild(d);
              dp.setParent(RESULT);
            :}
           | Decl:d
            {:RESULT= new BaseNode(NodeType.DECLARATIONS);
              RESULT.addChild(d);
              d.setParent(RESULT);
            :};

Macro ::= IMPORT STRINGCONST // TODO
        | DEFINE;

MacroPlus ::= MacroPlus Macro // TODO
            | Macro;

VariableDecl ::= Variable:v SEMICOLON {: RESULT=v; :};

VariableDeclPlus ::= VariableDeclPlus:vdp VariableDecl:vd
            {:RESULT=vdp;
              RESULT.addChild(vd);
              vd.setParent(RESULT);
            :}
            | VariableDecl:vd
            {:RESULT= new BaseNode(NodeType.VARIABLE_DECLARATIONS);;
              RESULT.addChild(vd);
              vd.setParent(RESULT);
            :};

Variable ::= Type:t IDENTIFIER:i
            {:RESULT= new BaseNode(NodeType.VARIABLE_DECLARATION);
              Node id = new IdentifierNode((String)i);
              RESULT.addChild(t);
              RESULT.addChild(id);
              t.setParent(RESULT);
              id.setParent(RESULT);
            :}
            | IDENTIFIER:i1 IDENTIFIER:i2 // TODO
            {:RESULT= new BaseNode(NodeType.VARIABLE_DECLARATION);
              Node id1 = new IdentifierNode((String)i1);
              Node id2 = new IdentifierNode((String)i2);
              RESULT.addChild(id1);
              RESULT.addChild(id2);
              id1.setParent(RESULT);
              id2.setParent(RESULT);
            :};

Type ::= INTEGER {: RESULT = new TypeNode(NodeType.INTEGER_TYPE, PrimitiveType.INT); :}
       | DOUBLE {: RESULT = new TypeNode(NodeType.DOUBLE_TYPE, PrimitiveType.DOUBLE); :}
       | BOOLEAN {: RESULT = new TypeNode(NodeType.BOOLEAN_TYPE, PrimitiveType.BOOL); :}
       | STRING  {: RESULT = new TypeNode(NodeType.STRING_TYPE, PrimitiveType.STRING); :}
       | Type:t LEFTBRACKET RIGHTBRACKET
       {:
         RESULT = t;
         Node e = new BaseNode(NodeType.EMPTY_ARRAY);
         RESULT.addChild(e);
         e.setParent(RESULT);
         :}
       | IDENTIFIER:i LEFTBRACKET RIGHTBRACKET // TODO
       {:
         RESULT = new IdentifierNode((String)i);
         Node e = new BaseNode(NodeType.EMPTY_ARRAY);
         RESULT.addChild(e);
         e.setParent(RESULT);
         :};

FunctionDecl ::= Type:t IDENTIFIER:i LEFTPARANTHESIS Formals:f RIGHTPARANTHESIS StatementBlock:s
         {:
			RESULT = new BaseNode(NodeType.FUNCTION_DECLARATION);
			Node id = new IdentifierNode((String)i);
			RESULT.addChild(t, id, f, s);
			t.setParent(RESULT);
			id.setParent(RESULT);
			f.setParent(RESULT);
			s.setParent(RESULT);
        :}
        | IDENTIFIER:i1 IDENTIFIER:i2 LEFTPARANTHESIS Formals:f RIGHTPARANTHESIS StatementBlock:s // TODO
        {:
			RESULT = new BaseNode(NodeType.FUNCTION_DECLARATION);
			Node id1 = new IdentifierNode((String)i1);
			Node id2 = new IdentifierNode((String)i2);
			RESULT.addChild(id1, id2, f, s);
			id1.setParent(RESULT);
			id2.setParent(RESULT);
			f.setParent(RESULT);
			s.setParent(RESULT);
       :}
        | VOID IDENTIFIER:i LEFTPARANTHESIS Formals:f RIGHTPARANTHESIS StatementBlock:s
         {:
            RESULT = new BaseNode(NodeType.FUNCTION_DECLARATION);
            Node t = new TypeNode(NodeType.VOID_TYPE, PrimitiveType.VOID);
            Node id = new IdentifierNode((String)i);
            RESULT.addChild(t, id, f, s);
            t.setParent(RESULT);
            id.setParent(RESULT);
            f.setParent(RESULT);
            s.setParent(RESULT);
        :};

Formals ::=  VariablePlusComma:vpc {: RESULT=vpc; :}
        |;

VariablePlusComma ::= VariablePlusComma:vpc COMMA Variable:v // TODO
                    {:
                    RESULT = vpc;
                    RESULT.addChild(v);
                    v.setParent(RESULT);
                    :}
                    | Variable:v
                    {:
                    RESULT = new BaseNode(NodeType.VARIABLE_PLUS_COMMA);
                    RESULT.addChild(v);
                    v.setParent(RESULT);
                    :};

ClassDecl ::= CLASS IDENTIFIER:i LEFTCURLY FieldPlus:fp  RIGHTCURLY
            {:
                RESULT = new ClassNode();
                Node id = new IdentifierNode((String)i);
                RESULT.addChild(id);
                RESULT.addChild(fp);
                id.setParent(RESULT);
                fp.setParent(RESULT);
            :}
            | CLASS IDENTIFIER:i LEFTCURLY RIGHTCURLY
            {:
                RESULT = new ClassNode();
                Node id = new IdentifierNode((String)i);
                RESULT.addChild(id);
                id.setParent(RESULT);
            :};

FieldPlus ::= FieldPlus:fp Field:f
            {:
                RESULT = fp;
                RESULT.addChild(f);
                f.setParent(RESULT);
            :}
            | Field:f
            {:
                RESULT = new BaseNode(NodeType.FIELDS);
                RESULT.addChild(f);
                f.setParent(RESULT);
            :};

Field ::= AccessMode:am VariableDecl:vd
            {:
                RESULT = new BaseNode(NodeType.FIELD_DECLARATION);
                RESULT.addChild(am);
                RESULT.addChild(vd);
                am.setParent(RESULT);
                vd.setParent(RESULT);
            :}
            | AccessMode:am FunctionDecl:fd
            {:
                RESULT = new BaseNode(NodeType.FIELD_DECLARATION);
                RESULT.addChild(am);
                RESULT.addChild(fd);
                am.setParent(RESULT);
                fd.setParent(RESULT);
            :};

AccessMode ::= PRIVATE
            {:
                RESULT = new BaseNode(NodeType.FUNCTION_ACCESS);
                Node t = new BaseNode(NodeType.PRIVATE_ACCESS);
                RESULT.addChild(t);
                t.setParent(RESULT);
            :}
            | PUBLIC
            {:
                RESULT = new BaseNode(NodeType.FUNCTION_ACCESS);
                Node t = new BaseNode(NodeType.PUBLIC_ACCESS);
                RESULT.addChild(t);
                t.setParent(RESULT);
            :}
            |;

StatementBlock ::= LEFTCURLY RIGHTCURLY
                {:
                    RESULT = new BaseNode(NodeType.BLOCK);
                :}
                | LEFTCURLY VariableDeclPlus:vdp RIGHTCURLY
                {:
                 RESULT = new BaseNode(NodeType.BLOCK);
                 RESULT.addChild(vdp);
                 vdp.setParent(RESULT);
                :}
                | LEFTCURLY StatementPlus:sp RIGHTCURLY
                {:
                RESULT = new BaseNode(NodeType.BLOCK);
                RESULT.addChild(sp);
                sp.setParent(RESULT);
                :}
                | LEFTCURLY VariableDeclPlus:vdp StatementPlus:sp RIGHTCURLY
                {:
                 RESULT = new BaseNode(NodeType.BLOCK);
                 RESULT.addChild(vdp);
                 RESULT.addChild(sp);
                 vdp.setParent(RESULT);
                 sp.setParent(RESULT);
                :};

StatementPlus ::= StatementPlus:sp Statement:s
             {:
                 RESULT = sp;
                 RESULT.addChild(s);
                 s.setParent(RESULT);
             :}
            | Statement:s
              {:
                 RESULT = new BaseNode(NodeType.STATEMENTS);
                 RESULT.addChild(s);
                 s.setParent(RESULT);
             :};

Statement ::= Expression:e SEMICOLON
            {:
              RESULT = new BaseNode(NodeType.STATEMENT);
              RESULT.addChild(e);
              e.setParent(RESULT);
            :}
            | SEMICOLON
          {:
            Node t = new BaseNode(NodeType.EMPTY_STATEMENT);
            RESULT = new BaseNode(NodeType.STATEMENT);
            RESULT.addChild(t);
            t.setParent(RESULT);
          :}
            | IfStatement:i
         {:
            RESULT = new BaseNode(NodeType.STATEMENT);
            RESULT.addChild(i);
            i.setParent(RESULT);
         :}
            | WhileStatement:w
         {:
            RESULT = new BaseNode(NodeType.STATEMENT);
            RESULT.addChild(w);
            w.setParent(RESULT);
         :}
            | ForStatement:f
         {:
            RESULT = new BaseNode(NodeType.STATEMENT);
            RESULT.addChild(f);
            f.setParent(RESULT);
         :}
            | BreakStatement:b
         {:
            RESULT = new BaseNode(NodeType.STATEMENT);
            RESULT.addChild(b);
            b.setParent(RESULT);
         :}
            | ContinueStatement:c
         {:
            RESULT = new BaseNode(NodeType.STATEMENT);
            RESULT.addChild(c);
            c.setParent(RESULT);
         :}
            | ReturnStatement:r
         {:
            RESULT = new BaseNode(NodeType.STATEMENT);
            RESULT.addChild(r);
            r.setParent(RESULT);
         :}
            | PrintStatement:p
         {:
            RESULT = new BaseNode(NodeType.STATEMENT);
            RESULT.addChild(p);
            p.setParent(RESULT);
         :}
            | StatementBlock:s
         {:
            RESULT = new BaseNode(NodeType.STATEMENT);
            RESULT.addChild(s);
            s.setParent(RESULT);
         :};

IfStatement ::= IF LEFTPARANTHESIS Expression:e RIGHTPARANTHESIS Statement:s ElsePrime:ep
            {:
                RESULT = new BaseNode(NodeType.IF_STATEMENT);
                RESULT.addChild(e, s, ep);
                e.setParent(RESULT);
                s.setParent(RESULT);
                ep.setParent(RESULT);
            :}
;

ElsePrime ::= ELSE Statement:s
            {:
                RESULT = new BaseNode(NodeType.IF_STATEMENT);
                RESULT.addChild(s);
                s.setParent(RESULT);
            :}
            |;

WhileStatement::= WHILE LEFTPARANTHESIS Expression:e RIGHTPARANTHESIS Statement:s
          {:
            RESULT = new BaseNode(NodeType.WHILE_STATEMENT);
            RESULT.addChild(e, s);
            e.setParent(RESULT);
            s.setParent(RESULT);
         :};

ForStatement ::= FOR LEFTPARANTHESIS SEMICOLON Expression:e2 SEMICOLON RIGHTPARANTHESIS Statement:s
            {:
                RESULT = new BaseNode(NodeType.FOR_STATEMENT);
                RESULT.addChild(e2, s);
                e2.setParent(RESULT);
                s.setParent(RESULT);
            :}
               | FOR LEFTPARANTHESIS Expression:e1 SEMICOLON Expression:e2 SEMICOLON RIGHTPARANTHESIS Statement:s
            {:
                RESULT = new BaseNode(NodeType.FOR_STATEMENT);
                RESULT.addChild(e1,e2,s);
                e1.setParent(RESULT);
                e2.setParent(RESULT);
                s.setParent(RESULT);
            :}
               | FOR LEFTPARANTHESIS  SEMICOLON Expression:e2 SEMICOLON Expression:e3 RIGHTPARANTHESIS Statement:s
            {:
                RESULT = new BaseNode(NodeType.FOR_STATEMENT);
                RESULT.addChild(e2,s,e3);
                e2.setParent(RESULT);
                e3.setParent(RESULT);
                s.setParent(RESULT);
            :}
               | FOR LEFTPARANTHESIS Expression:e1 SEMICOLON Expression:e2 SEMICOLON Expression:e3 RIGHTPARANTHESIS Statement:s
            {:
                RESULT = new BaseNode(NodeType.FOR_STATEMENT);
                RESULT.addChild(e1,e2,s,e3);
                e1.setParent(RESULT);
                e2.setParent(RESULT);
                e3.setParent(RESULT);
                s.setParent(RESULT);
            :};

ReturnStatement ::= RETURN SEMICOLON
                {:
                    RESULT = new BaseNode(NodeType.RETURN_STATEMENT);
                :}
                  | RETURN Expression:e SEMICOLON
                {:
                    RESULT = new BaseNode(NodeType.RETURN_STATEMENT);
                    RESULT.addChild(e);
                    e.setParent(RESULT);
                :};

BreakStatement ::= BREAK SEMICOLON
                {:
                    RESULT = new BaseNode(NodeType.BREAK_STATEMENT);
                :};

ContinueStatement ::= CONTINUE SEMICOLON
                {:
                    RESULT = new BaseNode(NodeType.CONTINUE_STATEMENT);
                :};

PrintStatement ::= PRINT LEFTPARANTHESIS ExpressionPlusComma:epc RIGHTPARANTHESIS SEMICOLON
                {:
                    RESULT = new BaseNode(NodeType.PRINT_STATEMENT);
                    RESULT.addChild(epc);
                    epc.setParent(RESULT);
                :};

ExpressionPlusComma ::= ExpressionPlusComma:epc COMMA Expression:e
                {:
                    RESULT = epc;
                    RESULT.addChild(e);
                    e.setParent(RESULT);
                :}
                | Expression:e
                {:
                    RESULT = new BaseNode(NodeType.EXPRESSION_PLUS_COMMA);
                    RESULT.addChild(e);
                    e.setParent(RESULT);
                :};

Expression ::= LValue:l ASSIGN Expression:e
         {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.ASSIGN);
            t.addChild(l);
            t.addChild(e);
            l.setParent(t);
            e.setParent(t);
            RESULT.addChild(t);
            t.setParent(RESULT);
        :}
         | IDENTIFIER:i ASSIGN Expression:e // TODO
         {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.ASSIGN);
            Node id = new IdentifierNode((String)i);
            t.addChild(id);
            t.addChild(e);
            id.setParent(t);
            e.setParent(t);
            RESULT.addChild(t);
            t.setParent(RESULT);
        :}
         | LValue:l ASSIGNADD Expression:e
         {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.ASSIGN_ADD);
            t.addChild(l);
            t.addChild(e);
            l.setParent(t);
            e.setParent(t);
            RESULT.addChild(t);
            t.setParent(RESULT);
        :}
         | IDENTIFIER:i ASSIGNADD Expression:e // TODO
         {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.ASSIGN_ADD);
            Node id = new IdentifierNode((String)i);
            t.addChild(id);
            t.addChild(e);
            id.setParent(t);
            e.setParent(t);
            RESULT.addChild(t);
            t.setParent(RESULT);
        :}
         | LValue:l ASSIGNSUB Expression:e
         {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.ASSIGN_SUB);
            t.addChild(l);
            t.addChild(e);
            l.setParent(t);
            e.setParent(t);
            RESULT.addChild(t);
            t.setParent(RESULT);
        :}
         | IDENTIFIER:i ASSIGNSUB Expression:e // TODO
         {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.ASSIGN_SUB);
            Node id = new IdentifierNode((String)i);
            t.addChild(id);
            t.addChild(e);
            id.setParent(t);
            e.setParent(t);
            RESULT.addChild(t);
            t.setParent(RESULT);
        :}
         | LValue:l ASSIGNMUL Expression:e
         {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.ASSIGN_MUL);
            t.addChild(l);
            t.addChild(e);
            l.setParent(t);
            e.setParent(t);
            RESULT.addChild(t);
            t.setParent(RESULT);
        :}
         | IDENTIFIER:i ASSIGNMUL Expression:e // TODO
         {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.ASSIGN_MUL);
            Node id = new IdentifierNode((String)i);
            t.addChild(id);
            t.addChild(e);
            id.setParent(t);
            e.setParent(t);
            RESULT.addChild(t);
            t.setParent(RESULT);
        :}
         | LValue:l ASSIGNDIV Expression:e
         {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.ASSIGN_DIV);
            t.addChild(l);
            t.addChild(e);
            l.setParent(t);
            e.setParent(t);
            RESULT.addChild(t);
            t.setParent(RESULT);
        :}
         | IDENTIFIER:i ASSIGNDIV Expression:e
         {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.ASSIGN_DIV);
            Node id = new IdentifierNode((String)i);
            t.addChild(id);
            t.addChild(e);
            id.setParent(t);
            e.setParent(t);
            RESULT.addChild(t);
            t.setParent(RESULT);
        :}
         | Constant:c
        {:
            RESULT = new ExpressionNode();
            RESULT.addChild(c);
            c.setParent(RESULT);
        :}
         | LValue:l
        {:
            RESULT = new ExpressionNode();
            RESULT.addChild(l);
            l.setParent(RESULT);
        :}
         | IDENTIFIER:i // TODO
        {:
            RESULT = new ExpressionNode();
            Node id = new IdentifierNode((String)i);
            RESULT.addChild(id);
            id.setParent(RESULT);
        :}
         | THIS
        {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.THIS);
            RESULT.addChild(t);
            t.setParent(RESULT);
        :}
         | Call:c
         {:
            RESULT = new ExpressionNode();
            RESULT.addChild(c);
            c.setParent(RESULT);
        :}
         | LEFTPARANTHESIS Expression:e RIGHTPARANTHESIS
         {:
            RESULT = e;
        :}
         | Expression:e1 ADD Expression:e2
        {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.ADDITION);
            t.addChild(e1);
            t.addChild(e2);
            RESULT.addChild(t);
            e1.setParent(t);
            e2.setParent(t);
            t.setParent(RESULT);
        :}
         | Expression:e1 SUB Expression:e2
        {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.SUBTRACTION);
            t.addChild(e1);
            t.addChild(e2);
            RESULT.addChild(t);
            e1.setParent(t);
            e2.setParent(t);
            t.setParent(RESULT);
        :}
         | Expression:e1 MUL Expression:e2
        {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.MULTIPLICATION);
            t.addChild(e1);
            t.addChild(e2);
            RESULT.addChild(t);
            e1.setParent(t);
            e2.setParent(t);
            t.setParent(RESULT);
        :}
         | Expression:e1 DIV Expression:e2
        {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.DIVISION);
            t.addChild(e1);
            t.addChild(e2);
            RESULT.addChild(t);
            e1.setParent(t);
            e2.setParent(t);
            t.setParent(RESULT);
        :}
         | Expression:e1 MOD Expression:e2
          {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.MOD);
            t.addChild(e1);
            t.addChild(e2);
            RESULT.addChild(t);
            e1.setParent(t);
            e2.setParent(t);
            t.setParent(RESULT);
        :}
         | SUB Expression:e
        {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.NEGATIVE);
            t.addChild(e);
            RESULT.addChild(t);
            t.setParent(RESULT);
            e.setParent(t);
        :}
         | Expression:e1 LESS Expression:e2
        {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.LESS_THAN);
            t.addChild(e1);
            t.addChild(e2);
            RESULT.addChild(t);
            e1.setParent(t);
            e2.setParent(t);
            t.setParent(RESULT);
        :}
         | Expression:e1 LESSEQUAL Expression:e2
        {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.LESS_EQUAL);
            t.addChild(e1);
            t.addChild(e2);
            RESULT.addChild(t);
            e1.setParent(t);
            e2.setParent(t);
            t.setParent(RESULT);
        :}
         | Expression:e1 GREATER Expression:e2
        {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.GREATER_THAN);
            t.addChild(e1);
            t.addChild(e2);
            RESULT.addChild(t);
            e1.setParent(t);
            e2.setParent(t);
            t.setParent(RESULT);
        :}
         | Expression:e1 GREATEREQUAL Expression:e2
        {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.GREATER_EQUAL);
            t.addChild(e1);
            t.addChild(e2);
            RESULT.addChild(t);
            e1.setParent(t);
            e2.setParent(t);
            t.setParent(RESULT);
        :}
         | Expression:e1 EQUAL Expression:e2
        {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.EQUAL);
            t.addChild(e1);
            t.addChild(e2);
            RESULT.addChild(t);
            e1.setParent(t);
            e2.setParent(t);
            t.setParent(RESULT);
        :}
         | Expression:e1 NOTEQUAL Expression:e2
        {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.NOT_EQUAL);
            t.addChild(e1);
            t.addChild(e2);
            RESULT.addChild(t);
            e1.setParent(t);
            e2.setParent(t);
            t.setParent(RESULT);
        :}
         | Expression:e1 AND Expression:e2
        {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.AND);
            t.addChild(e1);
            t.addChild(e2);
            RESULT.addChild(t);
            e1.setParent(t);
            e2.setParent(t);
            t.setParent(RESULT);
        :}
         | Expression:e1 OR Expression:e2
        {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.OR);
            t.addChild(e1);
            t.addChild(e2);
            RESULT.addChild(t);
            e1.setParent(t);
            e2.setParent(t);
            t.setParent(RESULT);
        :}
         | NOT Expression:e
        {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.NOT);
            t.addChild(e);
            RESULT.addChild(t);
            e.setParent(t);
            t.setParent(RESULT);
        :}
         | READINTEGER LEFTPARANTHESIS RIGHTPARANTHESIS
        {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.READ_INTEGER);
            RESULT.addChild(t);
            t.setParent(RESULT);
        :}
         | READLINE LEFTPARANTHESIS RIGHTPARANTHESIS
        {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.READ_LINE);
            RESULT.addChild(t);
            t.setParent(RESULT);
        :}
         | NEW IDENTIFIER:i
        {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.NEW_IDENTIFIER);
            Node id = new IdentifierNode((String)i);
            t.addChild(id);
            RESULT.addChild(t);
            t.setParent(RESULT);
            id.setParent(t);
        :}
         | NEWARRAY LEFTPARANTHESIS Expression:e COMMA Type:t RIGHTPARANTHESIS
        {:
            RESULT = new ExpressionNode();
            Node n = new BaseNode(NodeType.NEW_ARRAY);
            n.addChild(e);
            n.addChild(t);
            RESULT.addChild(n);
            n.setParent(RESULT);
            e.setParent(n);
            t.setParent(n);
        :}
         | NEWARRAY LEFTPARANTHESIS Expression:e COMMA IDENTIFIER:i RIGHTPARANTHESIS // TODO
        {:
            RESULT = new ExpressionNode();
            Node n = new BaseNode(NodeType.NEW_ARRAY);
            Node id = new IdentifierNode((String)i);
            n.addChild(e);
            n.addChild(id);
            RESULT.addChild(n);
            n.setParent(RESULT);
            e.setParent(n);
            id.setParent(n);
        :}
         | ITOD LEFTPARANTHESIS Expression:e RIGHTPARANTHESIS
        {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.ITOD);
            t.addChild(e);
            RESULT.addChild(t);
            t.setParent(RESULT);
            e.setParent(t);
        :}
         | DTOI LEFTPARANTHESIS Expression:e RIGHTPARANTHESIS
        {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.DTOI);
            t.addChild(e);
            RESULT.addChild(t);
            t.setParent(RESULT);
            e.setParent(t);
        :}
         | ITOB LEFTPARANTHESIS Expression:e RIGHTPARANTHESIS
        {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.ITOB);
            t.addChild(e);
            RESULT.addChild(t);
            t.setParent(RESULT);
            e.setParent(t);
        :}
         | BTOI LEFTPARANTHESIS Expression:e RIGHTPARANTHESIS
         {:
             RESULT = new ExpressionNode();
             Node t = new BaseNode(NodeType.BTOI);
             t.addChild(e);
             RESULT.addChild(t);
             t.setParent(RESULT);
             e.setParent(t);
         :}
         | LINE // TODO
        {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.LINE);
            RESULT.addChild(t);
            t.setParent(RESULT);
        :}
         | FUNCTION // TODO
        {:
            RESULT = new ExpressionNode();
            Node t = new BaseNode(NodeType.FUNCTION);
            RESULT.addChild(t);
            t.setParent(RESULT);
        :};

LValue ::= Expression:e DOT IDENTIFIER:i
        {:
            RESULT = new BaseNode(NodeType.LVALUE);
            Node id = new IdentifierNode((String)i);
            RESULT.addChild(id);
            RESULT.addChild(e);
            id.setParent(RESULT);
            e.setParent(RESULT);
        :}
         | Expression:e1 LEFTBRACKET Expression:e2 RIGHTBRACKET
        {:
            RESULT = new BaseNode(NodeType.LVALUE);
            RESULT.addChild(e1);
            RESULT.addChild(e2);
            e1.setParent(RESULT);
            e2.setParent(RESULT);
        :}
         | IDENTIFIER:i LEFTBRACKET Expression:e RIGHTBRACKET // TODO
        {:
            RESULT = new BaseNode(NodeType.LVALUE);
            Node id = new IdentifierNode((String)i);
            RESULT.addChild(id);
            RESULT.addChild(e);
            id.setParent(RESULT);
            e.setParent(RESULT);
        :};

Call ::= IDENTIFIER:i LEFTPARANTHESIS Actuals:a RIGHTPARANTHESIS
        {:
            RESULT = new BaseNode(NodeType.CALL);
            Node id = new IdentifierNode((String)i);
            RESULT.addChild(id);
            RESULT.addChild(a);
            id.setParent(RESULT);
            a.setParent(RESULT);
        :}
       | Expression:e DOT IDENTIFIER:i LEFTPARANTHESIS Actuals:a RIGHTPARANTHESIS
        {:
            RESULT = new BaseNode(NodeType.CALL);
            Node id = new IdentifierNode((String)i);
            RESULT.addChild(e);
            RESULT.addChild(id);
            RESULT.addChild(a);
            e.setParent(RESULT);
            id.setParent(RESULT);
            a.setParent(RESULT);
        :};

Actuals ::= ExpressionPlusComma:e
            {:
                RESULT = new BaseNode(NodeType.ACTUALS);
                RESULT.addChild(e);
                e.setParent(RESULT);
            :}
            |;

Constant ::= INTCONST:i
        {: RESULT = new IntegerLiteralNode((int)i); :}
            | DOUBLECONST:d
        {: RESULT = new DoubleLiteralNode((float)d); :}
            | BOOLCONST:b
        {: RESULT = new BooleanLiteralNode((boolean)b); :}
            | STRINGCONST:s
        {: RESULT = new StringLiteralNode((String)s); :}
            | NULL:n
        {: RESULT = new BaseNode(NodeType.NULL_LITERAL); :}
        ;
